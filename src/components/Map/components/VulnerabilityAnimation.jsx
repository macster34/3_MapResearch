import React, { useState, useEffect, useRef } from 'react';
import styled from 'styled-components';

const AnimationPanel = styled.div`
  position: fixed;
  left: 24px;
  top: 50%;
  transform: translateY(-50%);
  z-index: 1001;
  background: rgba(20, 20, 30, 0.95);
  color: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
  padding: 24px;
  min-width: 320px;
  max-width: 400px;
  display: flex;
  flex-direction: column;
  gap: 16px;
`;

const Title = styled.div`
  font-weight: 700;
  font-size: 18px;
  margin-bottom: 8px;
  text-align: center;
  color: #fff;
`;

const NeighborhoodSection = styled.div`
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
`;

const NeighborhoodCard = styled.div`
  flex: 1;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  padding: 12px;
  border-left: 4px solid ${props => props.$color};
  text-align: center;
`;

const NeighborhoodTitle = styled.div`
  font-weight: 600;
  font-size: 12px;
  margin-bottom: 4px;
  color: ${props => props.$color};
`;

const CallCount = styled.div`
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 4px;
  color: #fff;
`;

const DateLabel = styled.div`
  font-size: 10px;
  opacity: 0.7;
  color: #ccc;
`;

const TimeSlider = styled.input`
  width: 100%;
  margin: 8px 0;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
  outline: none;
  
  &::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #27ae60;
    cursor: pointer;
  }
  
  &::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #27ae60;
    cursor: pointer;
    border: none;
  }
`;

const PlayButton = styled.button`
  background: ${props => props.$isPlaying ? '#e74c3c' : '#27ae60'};
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 10px 20px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  margin-top: 8px;
  width: 100%;
  transition: all 0.2s ease;
  
  &:hover {
    background: ${props => props.$isPlaying ? '#c0392b' : '#229954'};
  }
`;

const ProgressBar = styled.div`
  width: 100%;
  height: 4px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 2px;
  overflow: hidden;
  margin-top: 8px;
`;

const ProgressFill = styled.div`
  height: 100%;
  background: #27ae60;
  width: ${props => props.$progress}%;
  transition: width 0.3s ease;
`;

const SubcategorySection = styled.div`
  display: flex;
  gap: 12px;
  margin-top: 12px;
`;

const SubcategoryCard = styled.div`
  flex: 1;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  padding: 10px;
`;

const SubcategoryTitle = styled.div`
  font-weight: 600;
  font-size: 11px;
  margin-bottom: 6px;
  text-align: center;
  color: ${props => props.$color};
`;

const SubcategoryList = styled.div`
  font-size: 9px;
  line-height: 1.2;
`;

const SubcategoryItem = styled.div`
  display: flex;
  justify-content: space-between;
  margin-bottom: 2px;
  padding: 1px 0;
`;

const VulnerabilityAnimation = ({ 
  map, 
  isVisible, 
  onAnimationUpdate
}) => {
  const [currentDay, setCurrentDay] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [animationData, setAnimationData] = useState(null);
  const [currentData, setCurrentData] = useState({});
  const animationRef = useRef(null);
  
  // Generate dates for June, July, August 2024
  const generateDates = () => {
    const dates = [];
    const months = [
      { month: 5, days: 30 }, // June (0-indexed)
      { month: 6, days: 31 }, // July
      { month: 7, days: 31 }  // August
    ];
    
    months.forEach(({ month, days }) => {
      for (let day = 1; day <= days; day++) {
        dates.push(new Date(2024, month, day));
      }
    });
    
    return dates;
  };
  
  const dates = generateDates();
  const neighborhoods = {
    mostVulnerable: {
      name: 'Neighborhood_50',
      color: '#e74c3c',
      label: 'Super Neighborhood 50'
    },
    leastVulnerable: {
      name: 'Neighborhood_3', 
      color: '#c0392b', // Changed from green to darker red
      label: 'Super Neighborhood 3'
    }
  };

  useEffect(() => {
    // Load animation data
    const loadData = async () => {
      try {
        const [juneResponse, julyResponse, augustResponse] = await Promise.all([
          fetch('/June_Comprehensive_Category_Dataset.geojson'),
          fetch('/July_Comprehensive_Category_Dataset.geojson'),
          fetch('/August_Comprehensive_Category_Dataset.geojson')
        ]);
        
        const juneData = await juneResponse.json();
        const julyData = await julyResponse.json();
        const augustData = await augustResponse.json();
        
        setAnimationData({
          June: juneData,
          July: julyData,
          August: augustData
        });
      } catch (error) {
        console.error('Error loading animation data:', error);
      }
    };
    
    if (isVisible) {
      loadData();
    }
  }, [isVisible]);

  useEffect(() => {
    if (!isPlaying || !animationData) return;

    const animate = () => {
      setCurrentDay(prev => {
        const next = prev + 1;
        if (next >= dates.length) {
          setIsPlaying(false);
          return 0;
        }
        return next;
      });
    };

    animationRef.current = setInterval(animate, 1000); // 1 second per day

    return () => {
      if (animationRef.current) {
        clearInterval(animationRef.current);
      }
    };
  }, [isPlaying, animationData, dates.length]);

  useEffect(() => {
    // Communicate current day to parent for map updates ONLY when playing
    if (onAnimationUpdate) {
      if (isPlaying) {
        onAnimationUpdate(currentDay);
      } else {
        // Hide markers when not playing
        onAnimationUpdate(null);
      }
    }
  }, [currentDay, isPlaying, onAnimationUpdate]);

  // Initial effect to ensure no markers are shown on mount
  useEffect(() => {
    if (onAnimationUpdate) {
      onAnimationUpdate(null);
    }
  }, [onAnimationUpdate]);

  // Update current data when day or animation data changes
  useEffect(() => {
    const updateCurrentData = async () => {
      if (animationData) {
        const data = await getCurrentDayData();
        setCurrentData(data);
      }
    };
    
    updateCurrentData();
  }, [currentDay, animationData]);

  const handlePlayPause = () => {
    if (isPlaying) {
      setIsPlaying(false);
      // Notify parent to hide animation layers
      if (onAnimationUpdate) {
        onAnimationUpdate(null);
      }
    } else {
      setIsPlaying(true);
      // Reset to day 0 when starting animation
      setCurrentDay(0);
      // Notify parent to show animation layers starting from day 0
      if (onAnimationUpdate) {
        onAnimationUpdate(0);
      }
    }
  };

  const handleSliderChange = (e) => {
    const newDay = parseInt(e.target.value);
    setCurrentDay(newDay);
    setIsPlaying(false);
    // Update the map to show markers for the selected day
    if (onAnimationUpdate) {
      onAnimationUpdate(newDay);
    }
  };

  const getCurrentDayData = async () => {
    if (!animationData) return {};
    
    const currentDate = dates[currentDay];
    const dateString = currentDate.toISOString().split('T')[0];
    const month = currentDate.getMonth();
    
    // Determine which month's data to use
    let monthData;
    if (month === 5) monthData = animationData.June; // June
    else if (month === 6) monthData = animationData.July; // July
    else if (month === 7) monthData = animationData.August; // August
    else return {};
    
    if (!monthData) return {};
    
    try {
      // Load Super Neighborhood boundaries for spatial filtering
      const boundariesResponse = await fetch('/super-neighborhoods-vulnerability-index.geojson');
      const boundariesData = await boundariesResponse.json();
      
      const targetBoundaries = boundariesData.features.filter(feature => 
        feature.properties.neighborhood_name === 'Neighborhood_50' || 
        feature.properties.neighborhood_name === 'Neighborhood_3'
      );
      
      // Filter calls for the current date AND location (within Super Neighborhood boundaries)
      const filteredCalls = monthData.features.filter(feature => {
        const callDate = feature.properties['Created Date Local'];
        if (!callDate || !callDate.startsWith(dateString)) {
          return false;
        }
        
        // Check if call is within any of the target Super Neighborhood boundaries
        const callPoint = feature.geometry;
        return targetBoundaries.some(boundary => {
          // Simple point-in-polygon check
          return isPointInPolygon(callPoint, boundary.geometry);
        });
      });
      
      // Separate calls by neighborhood
      const neighborhood50Calls = [];
      const neighborhood3Calls = [];
      
      filteredCalls.forEach(call => {
        const callPoint = call.geometry;
        const isIn50 = targetBoundaries.find(b => 
          b.properties.neighborhood_name === 'Neighborhood_50' && 
          isPointInPolygon(callPoint, b.geometry)
        );
        const isIn3 = targetBoundaries.find(b => 
          b.properties.neighborhood_name === 'Neighborhood_3' && 
          isPointInPolygon(callPoint, b.geometry)
        );
        
        if (isIn50) {
          neighborhood50Calls.push(call);
        }
        if (isIn3) {
          neighborhood3Calls.push(call);
        }
      });
      
      // Calculate subcategory breakdown for each neighborhood
      const getSubcategoryBreakdown = (calls) => {
        const breakdown = {};
        calls.forEach(call => {
          const category = call.properties.Category || 'Other';
          breakdown[category] = (breakdown[category] || 0) + 1;
        });
        return breakdown;
      };
      
      return {
        mostVulnerable: {
          calls: neighborhood50Calls.length,
          subcategories: getSubcategoryBreakdown(neighborhood50Calls)
        },
        leastVulnerable: {
          calls: neighborhood3Calls.length,
          subcategories: getSubcategoryBreakdown(neighborhood3Calls)
        }
      };
    } catch (error) {
      console.error('Error calculating neighborhood-specific data:', error);
      return {};
    }
  };

  // Helper function to check if a point is inside a polygon
  const isPointInPolygon = (point, polygon) => {
    if (polygon.type !== 'Polygon' && polygon.type !== 'MultiPolygon') {
      return false;
    }
    
    const x = point.coordinates[0];
    const y = point.coordinates[1];
    
    if (polygon.type === 'Polygon') {
      return isPointInPolygonCoords(x, y, polygon.coordinates[0]);
    } else {
      // MultiPolygon
      return polygon.coordinates.some(ring => isPointInPolygonCoords(x, y, ring[0]));
    }
  };
  
  const isPointInPolygonCoords = (x, y, coords) => {
    let inside = false;
    for (let i = 0, j = coords.length - 1; i < coords.length; j = i++) {
      const xi = coords[i][0], yi = coords[i][1];
      const xj = coords[j][0], yj = coords[j][1];
      
      if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
        inside = !inside;
      }
    }
    return inside;
  };

  const getTopSubcategories = (subcategories, limit = 3) => {
    return Object.entries(subcategories)
      .sort(([,a], [,b]) => b - a)
      .slice(0, limit);
  };

  const progress = ((currentDay + 1) / dates.length) * 100;
  const currentDate = dates[currentDay];

  // Debug logging
  console.log('VulnerabilityAnimation render:', { 
    isVisible, 
    currentDay, 
    currentDate: currentDate?.toDateString(),
    currentData 
  });

  if (!isVisible) return null;

  return (
    <AnimationPanel>
      <Title>Vulnerability Animation</Title>
      
      <NeighborhoodSection>
        <NeighborhoodCard $color={neighborhoods.mostVulnerable.color}>
          <NeighborhoodTitle $color={neighborhoods.mostVulnerable.color}>
            {neighborhoods.mostVulnerable.label}
          </NeighborhoodTitle>
          <CallCount>{currentData.mostVulnerable?.calls || 0}</CallCount>
          <DateLabel>{currentDate?.toLocaleDateString()}</DateLabel>
        </NeighborhoodCard>
        
        <NeighborhoodCard $color={neighborhoods.leastVulnerable.color}>
          <NeighborhoodTitle $color={neighborhoods.leastVulnerable.color}>
            {neighborhoods.leastVulnerable.label}
          </NeighborhoodTitle>
          <CallCount>{currentData.leastVulnerable?.calls || 0}</CallCount>
          <DateLabel>{currentDate?.toLocaleDateString()}</DateLabel>
        </NeighborhoodCard>
      </NeighborhoodSection>

      <TimeSlider
        type="range"
        min={0}
        max={dates.length - 1}
        value={currentDay}
        onChange={handleSliderChange}
      />

      <PlayButton $isPlaying={isPlaying} onClick={handlePlayPause}>
        {isPlaying ? '⏸ Pause' : '▶ Play Animation'}
      </PlayButton>

      <ProgressBar>
        <ProgressFill $progress={progress} />
      </ProgressBar>

      <SubcategorySection>
        <SubcategoryCard>
          <SubcategoryTitle $color={neighborhoods.mostVulnerable.color}>
            Top 311 Categories
          </SubcategoryTitle>
          <SubcategoryList>
            {getTopSubcategories(currentData.mostVulnerable?.subcategories || {}).map(([name, count]) => (
              <SubcategoryItem key={name}>
                <span>{name}</span>
                <span>{count}</span>
              </SubcategoryItem>
            ))}
          </SubcategoryList>
        </SubcategoryCard>
        
        <SubcategoryCard>
          <SubcategoryTitle $color={neighborhoods.leastVulnerable.color}>
            Top 311 Categories
          </SubcategoryTitle>
          <SubcategoryList>
            {getTopSubcategories(currentData.leastVulnerable?.subcategories || {}).map(([name, count]) => (
              <SubcategoryItem key={name}>
                <span>{name}</span>
                <span>{count}</span>
              </SubcategoryItem>
            ))}
          </SubcategoryList>
        </SubcategoryCard>
      </SubcategorySection>
    </AnimationPanel>
  );
};

export default VulnerabilityAnimation; 
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Point
import json

def calculate_vulnerability_index():
    """
    Calculate vulnerability index for Super Neighborhoods based on:
    1. July 311 calls (higher = more vulnerable)
    2. 2022 median income (lower = more vulnerable)
    3. Flood plain coverage (higher = more vulnerable)
    4. Community centers (no center = more vulnerable)
    5. Churches (more and larger churches = less vulnerable)
    """
    
    print("Loading data files...")
    
    # Load Super Neighborhoods
    super_neighborhoods = gpd.read_file('houston-super-neighborhoods.geojson')
    print(f"Loaded {len(super_neighborhoods)} Super Neighborhoods")
    
    # Load July 311 calls
    july_311_calls = gpd.read_file('July_Comprehensive_Category_Dataset.geojson')
    print(f"Loaded {len(july_311_calls)} July 311 calls")
    
    # Load 2022 median income (census tracts)
    income_data = gpd.read_file('harris_tracts_2022_income copy.geojson')
    print(f"Loaded {len(income_data)} census tracts with income data")
    
    # Load community centers
    community_centers = gpd.read_file('houston-community-centers-vulnerability-4326.geojson')
    print(f"Loaded {len(community_centers)} community centers")
    
    # Load churches
    churches = gpd.read_file('houston_churches_with_grace.geojson')
    print(f"Loaded {len(churches)} churches")
    
    # Load flood plains
    flood_plains = gpd.read_file('houston-texas-flood-100-500.geojson')
    print(f"Loaded {len(flood_plains)} flood plain features")
    
    # Ensure all data is in the same CRS
    target_crs = 'EPSG:4326'
    super_neighborhoods = super_neighborhoods.to_crs(target_crs)
    july_311_calls = july_311_calls.to_crs(target_crs)
    income_data = income_data.to_crs(target_crs)
    churches = churches.to_crs(target_crs)
    flood_plains = flood_plains.to_crs(target_crs)
    
    # Initialize vulnerability scores
    vulnerability_scores = []
    
    print("Calculating vulnerability index for each Super Neighborhood...")
    
    for idx, neighborhood in super_neighborhoods.iterrows():
        neighborhood_geom = neighborhood.geometry
        neighborhood_name = neighborhood.get('SUPER_NEIGHBORHOOD', f'Neighborhood_{idx}')
        
        print(f"Processing {neighborhood_name}...")
        
        # 1. Count July 311 calls within this Super Neighborhood
        calls_in_neighborhood = july_311_calls[july_311_calls.geometry.within(neighborhood_geom)]
        call_count = len(calls_in_neighborhood)
        
        # 2. Calculate average median income for census tracts within this Super Neighborhood
        tracts_in_neighborhood = income_data[income_data.geometry.intersects(neighborhood_geom)]
        if len(tracts_in_neighborhood) > 0:
            # Calculate weighted average based on intersection area
            weighted_income = 0
            total_weight = 0
            
            for _, tract in tracts_in_neighborhood.iterrows():
                intersection = tract.geometry.intersection(neighborhood_geom)
                weight = intersection.area
                income = tract.get('median_income_2022', 0)
                weighted_income += income * weight
                total_weight += weight
            
            avg_median_income = weighted_income / total_weight if total_weight > 0 else 0
        else:
            avg_median_income = 0
        
        # 3. Calculate flood plain coverage within this Super Neighborhood
        flood_in_neighborhood = flood_plains[flood_plains.geometry.intersects(neighborhood_geom)]
        flood_coverage = 0
        
        if len(flood_in_neighborhood) > 0:
            for _, flood in flood_in_neighborhood.iterrows():
                intersection = flood.geometry.intersection(neighborhood_geom)
                flood_coverage += intersection.area
            
            # Convert to percentage of neighborhood area
            neighborhood_area = neighborhood_geom.area
            flood_percentage = (flood_coverage / neighborhood_area) * 100 if neighborhood_area > 0 else 0
        else:
            flood_percentage = 0
        
        # 4. Check if Super Neighborhood has a community center and calculate total square footage
        centers_in_neighborhood = community_centers[community_centers.geometry.within(neighborhood_geom)]
        has_community_center = len(centers_in_neighborhood) > 0
        
        # Calculate total square footage of community centers in this neighborhood
        total_square_footage = 0
        if has_community_center:
            for _, center in centers_in_neighborhood.iterrows():
                # Get square footage from the center data and convert to number
                square_footage_raw = center.get('Square_Foo', 0)
                try:
                    square_footage = float(square_footage_raw) if square_footage_raw else 0
                except (ValueError, TypeError):
                    square_footage = 0
                if square_footage > 0:
                    total_square_footage += square_footage
        
        # 5. Count churches and calculate total church area in this Super Neighborhood
        churches_in_neighborhood = churches[churches.geometry.within(neighborhood_geom)]
        church_count = len(churches_in_neighborhood)
        
        # Calculate total church area (property size)
        total_church_area = 0
        if church_count > 0:
            for _, church in churches_in_neighborhood.iterrows():
                church_area = church.get('area_sq_ft', 0)
                try:
                    church_area = float(church_area) if church_area else 0
                except (ValueError, TypeError):
                    church_area = 0
                if church_area > 0:
                    total_church_area += church_area
        
        # Calculate community center score based on presence and size
        # No center = high vulnerability (1.0)
        # Small center (< 5000 sq ft) = medium vulnerability (0.7)
        # Medium center (5000-15000 sq ft) = low-medium vulnerability (0.3)
        # Large center (> 15000 sq ft) = low vulnerability (0.0)
        if not has_community_center:
            community_center_score = 1.0
        elif total_square_footage < 5000:
            community_center_score = 0.7
        elif total_square_footage < 15000:
            community_center_score = 0.3
        else:
            community_center_score = 0.0
        
        # Calculate church score based on count and total area
        # No churches = high vulnerability (1.0)
        # 1-2 churches with small area (< 50,000 sq ft) = medium vulnerability (0.7)
        # 3-5 churches or large area (50,000-200,000 sq ft) = low-medium vulnerability (0.3)
        # 6+ churches or very large area (> 200,000 sq ft) = low vulnerability (0.0)
        if church_count == 0:
            church_score = 1.0
        elif church_count <= 2 and total_church_area < 50000:
            church_score = 0.7
        elif church_count <= 5 and total_church_area < 200000:
            church_score = 0.3
        else:
            church_score = 0.0
        
        # Calculate normalized scores (0-1 scale)
        # For calls: normalize by max calls across all neighborhoods
        # For income: lower income = higher vulnerability
        # For flood: higher percentage = higher vulnerability
        # For community centers: no center = higher vulnerability (1.0), has center = lower vulnerability (0.0)
        # For churches: no churches = higher vulnerability (1.0), many/large churches = lower vulnerability (0.0)
        
        # Get max values for normalization
        all_call_counts = []
        all_incomes = []
        all_flood_percentages = []
        
        # This is a simplified approach - in production you'd want to calculate these once
        max_calls = 5000  # We'll adjust this after first pass
        min_income = 20000  # We'll adjust this after first pass
        max_flood = 100  # We'll adjust this after first pass
        
        # Normalize scores (higher = more vulnerable)
        call_score = min(call_count / max_calls, 1.0) if max_calls > 0 else 0
        income_score = max(0, 1 - (avg_median_income - min_income) / (150000 - min_income)) if avg_median_income > 0 else 1
        flood_score = min(flood_percentage / max_flood, 1.0) if max_flood > 0 else 0
        
        # Calculate composite vulnerability index (equal weights for all 5 factors)
        # Higher index = more vulnerable
        vulnerability_index = (call_score + income_score + flood_score + community_center_score + church_score) / 5
        
        vulnerability_scores.append({
            'neighborhood_name': neighborhood_name,
            'geometry': neighborhood_geom,
            'call_count': call_count,
            'avg_median_income': avg_median_income,
            'flood_percentage': flood_percentage,
            'has_community_center': has_community_center,
            'total_square_footage': total_square_footage,
            'church_count': church_count,
            'total_church_area': total_church_area,
            'call_score': call_score,
            'income_score': income_score,
            'flood_score': flood_score,
            'community_center_score': community_center_score,
            'church_score': church_score,
            'vulnerability_index': vulnerability_index
        })
        
        center_status = f"Center: {total_square_footage:,.0f} sq ft" if has_community_center else "No Center"
        church_status = f"Churches: {church_count} ({total_church_area:,.0f} sq ft)" if church_count > 0 else "No Churches"
        print(f"  - Calls: {call_count}, Income: ${avg_median_income:,.0f}, Flood: {flood_percentage:.1f}%, {center_status}, {church_status}, Vulnerability: {vulnerability_index:.3f}")
    
    # Create GeoJSON output
    output_features = []
    for score in vulnerability_scores:
        feature = {
            'type': 'Feature',
            'geometry': {
                'type': 'Polygon',
                'coordinates': [list(score['geometry'].exterior.coords)]
            },
            'properties': {
                'neighborhood_name': score['neighborhood_name'],
                'call_count': score['call_count'],
                'avg_median_income': score['avg_median_income'],
                'flood_percentage': score['flood_percentage'],
                'has_community_center': score['has_community_center'],
                'total_square_footage': score['total_square_footage'],
                'church_count': score['church_count'],
                'total_church_area': score['total_church_area'],
                'call_score': score['call_score'],
                'income_score': score['income_score'],
                'flood_score': score['flood_score'],
                'community_center_score': score['community_center_score'],
                'church_score': score['church_score'],
                'vulnerability_index': score['vulnerability_index']
            }
        }
        output_features.append(feature)
    
    output_geojson = {
        'type': 'FeatureCollection',
        'features': output_features
    }
    
    # Save to file
    with open('super-neighborhoods-vulnerability-index.geojson', 'w') as f:
        json.dump(output_geojson, f)
    
    print(f"\nVulnerability index calculated for {len(vulnerability_scores)} Super Neighborhoods")
    print("Results saved to: super-neighborhoods-vulnerability-index.geojson")
    
    # Print summary statistics
    indices = [score['vulnerability_index'] for score in vulnerability_scores]
    print(f"\nVulnerability Index Summary:")
    print(f"  Min: {min(indices):.3f}")
    print(f"  Max: {max(indices):.3f}")
    print(f"  Mean: {np.mean(indices):.3f}")
    print(f"  Median: {np.median(indices):.3f}")
    
    return vulnerability_scores

if __name__ == "__main__":
    calculate_vulnerability_index() 
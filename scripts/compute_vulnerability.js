const fs = require('fs');
const path = require('path');

// Input files
const centersPath = path.join(__dirname, '../public/houston-texas-community-centers.geojson');
const censusPath = path.join(__dirname, '../public/data_bundles/houston_small_files/houston-census-blocks.geojson');
const outputPath = path.join(__dirname, '../public/houston-community-centers-vulnerability.geojson');

// Load GeoJSON files
const centers = JSON.parse(fs.readFileSync(centersPath, 'utf8'));
const census = JSON.parse(fs.readFileSync(censusPath, 'utf8'));

// 1. Build ZIP code to median income lookup (use average if multiple blocks per ZIP)
const zipToIncomes = {};
census.features.forEach(f => {
  const zip = f.properties.Zip_Code || f.properties.ZIP || f.properties.zip || f.properties.ZCTA5CE10;
  const income = f.properties.median_income || f.properties.Median_Income || f.properties.MEDIAN_INC || f.properties.MEDIAN_HH_INC;
  if (zip && income && !isNaN(Number(income))) {
    if (!zipToIncomes[zip]) zipToIncomes[zip] = [];
    zipToIncomes[zip].push(Number(income));
  }
});
const zipToMedianIncome = {};
for (const zip in zipToIncomes) {
  const arr = zipToIncomes[zip];
  zipToMedianIncome[zip] = arr.reduce((a, b) => a + b, 0) / arr.length;
}

// 2. Collect all values for normalization
const distances = [];
const sizes = [];
const incomes = [];
centers.features.forEach(f => {
  const d = Number(f.properties.distance_to_floodplain_km);
  const s = Number(f.properties.Square_Foo);
  const zip = f.properties.Zip_Code;
  const income = zipToMedianIncome[zip];
  if (!isNaN(d)) distances.push(d);
  if (!isNaN(s)) sizes.push(s);
  if (!isNaN(income)) incomes.push(income);
});

const minMax = arr => [Math.min(...arr), Math.max(...arr)];
const [minDist, maxDist] = minMax(distances);
const [minSize, maxSize] = minMax(sizes);
const [minInc, maxInc] = minMax(incomes);

// 3. Add normalized values and vulnerability score
centers.features.forEach(f => {
  const d = Number(f.properties.distance_to_floodplain_km);
  const s = Number(f.properties.Square_Foo);
  const zip = f.properties.Zip_Code;
  const income = zipToMedianIncome[zip];

  // Normalize (0-1)
  const normDist = isNaN(d) ? 0 : (d - minDist) / (maxDist - minDist);
  const normSize = isNaN(s) ? 0 : (s - minSize) / (maxSize - minSize);
  const normInc = isNaN(income) ? 0 : (income - minInc) / (maxInc - minInc);

  // Vulnerability: higher = more vulnerable
  // (closer to floodplain, smaller size, lower income)
  const vulnerability = (
    (1 - normDist) + // closer = more vulnerable
    (1 - normSize) + // smaller = more vulnerable
    (1 - normInc)    // lower income = more vulnerable
  ) / 3;

  f.properties.median_income = income || null;
  f.properties.vulnerability = vulnerability;
});

// 4. Write new GeoJSON
fs.writeFileSync(outputPath, JSON.stringify(centers, null, 2));
console.log('Wrote vulnerability GeoJSON to', outputPath); 